# frozen_string_literal: true

# Common accessors into bib item data
#
# Note: Redis and SymphonyClient used in private method to dynamically retrieve and store item type code
# translations.
module BibRecord
  def catkey
    fields.dig('bib', 'key') || item.dig('bib', 'key')
  end

  def item_type_code
    item.dig('itemType', 'key')
  end

  def item_type_human
    item_type_mapping.find { |type| type['key'] == item_type_code }&.dig('fields', 'description') || item_type_code
  end

  def title
    bib['title']
  end

  def author
    bib['author']
  end

  # The OR is used in hold requests, generated by bib calls to symphony's web service
  def call_number
    call['dispCallNumber'] || fields['dispCallNumber']
  end

  def resource
    fields.dig('item', 'resource')
  end

  def item_key
    fields.dig('item', 'key')
  end

  def bib_summary
    "#{title} (#{call_number})"
  end

  def shadowed?
    bib['shadowed']
  end

  private

    def item
      fields.dig('item', 'fields') || {}
    end

    def bib
      fields&.dig('bib', 'fields') || fields&.dig('item', 'fields', 'bib', 'fields') || {}
    end

    def call
      item.dig('call', 'fields') || {}
    end

    # Use Redis to store this globally once an hour
    def item_type_mapping
      Rails.cache.fetch(['item_type_map', __method__], expires_in: 60.minutes) do
        client = SymphonyClient.new
        item_type_map = client.get_item_type_map.to_json
        JSON.parse(item_type_map)
      end
    end
end
